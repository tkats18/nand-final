class TableManager{

    field ShipManager shipManager ;
    field Random random;

    field Array leftData;
    field Array rightData;
    
    field int startXLeft;
    field int startYLeft;

    field int startXRight;
    field int startYRight;

    constructor TableManager new(Random rand){

        let random = rand;
        
        let startXLeft = 25;
        let startYLeft = 18;

        let startXRight = 260;
        let startYRight = 18;

        let leftData = initializeBoard(startXLeft,startYLeft);
        let rightData = initializeBoard(startXRight,startYRight);

        let shipManager = ShipManager.new();

        return this;
    }

    method Array initializeBoard(int x, int y){
        var int i,j;
        var  Array data;

        let i=0;
        let j=0;
        let data = Array.new(100);

        while (j<10){

            while (i<10){

                let data[(j*10)+i] = Square.new((20*i) + x, (20*j) + y, i+(10*j), 20);
                let i = i + 1;
                
            }
            let i = 0;
            let j = j + 1;
        
        }

        return data;
    }

    method void generateCumputerShips(){

        do generateShipWithLength(5,0);
        do generateShipWithLength(4,1);
        do generateShipWithLength(3,2);
        do generateShipWithLength(2,3);
        do generateShipWithLength(2,4);
        do generateShipWithLength(1,5);
        do generateShipWithLength(1,6);

        return;
    }

    method void generateShipWithLength(int len,int ind){

        var int direction, pos, curX, curY;
        var Square curSq;
        var boolean end;

        let end = false;
        let pos = -1;
        let direction = -1;
        let curX = -1;
        let curY = -1;


        while(~(end)){
            let pos = random.generateRandom(100);
            let curX = pos - (Math.divide(pos, 10) * 10);
            let curY = Math.divide(pos, 10);

            let curSq = rightData[pos];
            if (~(curSq.getIsChosen())){
                let direction = random.generateRandom(2);
        
                if (direction = 0){
                    if (checkNToRight(curY,curX,len)){
                        // do Output.printString("right");
                        do fillNToRight(curY,curX,len,ind);
                        let end = true; 
                    }
                }
                
                if (direction = 1){
                    if(checkNToDown(curY,curX,len)){
                        // do Output.printString("down");
                        
                        do fillNToDown(curY,curX,len,ind);
                        let end = true; 
                    }
                }
            }

        } 
        return;

    }

    method void fillNToRight(int i, int j, int len,int ind){
        var Square curSq;

        var int k;
        let k = 0;

        while(k<len){            
            let curSq = rightData[(10*i)+j+k];
            do curSq.choose();
            do curSq.setShipIndex(ind);
            do shipManager.addToComputerShip(ind,curSq);
            let k = k + 1;
        }

        return;
    }

    method void fillNToDown(int i, int j, int len,int ind){
        var Square curSq;

        var int k;
        let k = 0;

        while(k<len){            
            let curSq = rightData[(10*(i+k))+j];
            do curSq.choose();
            do curSq.setShipIndex(ind);

            do shipManager.addToComputerShip(ind,curSq);
            let k = k + 1;
        }

        return;
    }


    method boolean checkNToRight(int i, int j, int len){
        var Square curSq;

        var int k;
        let k = 0;

        while(k<len){
            if (~(checkAllSides(i,j+k))){
                return false;
            }
        
            let k = k + 1;
        }

        return true;
    }

    method boolean checkNToDown(int i, int j, int len){
        var Square curSq;

        var int k;
        let k = 0;

        while(k<len){

            if (~(checkAllSides(i + k,j))){
                return false;
            }

            let k = k + 1;
        }

        return true;
    }


    method boolean checkAllSides(int i, int j){
        var boolean thisSq, left, right, top, down, leftTop, rightTop, downRight, downLeft;    
        
        let thisSq = checkRightSquare(i,j);
        let left = checkRightSquare(i,j-1);
        let right = checkRightSquare(i,j+1);
        let top = checkRightSquare(i-1,j);
        let down = checkRightSquare(i+1,j);
        let leftTop = checkRightSquare(i-1,j-1);
        let rightTop = checkRightSquare(i+1,j-1);
        let downRight = checkRightSquare(i-1,j+1);
        let downLeft = checkRightSquare(i+1,j+1);

        return ( checkBorders(i,j) & (thisSq & left & right & top & down & leftTop & rightTop & downRight & downLeft));

    }

    

    method boolean validate(){

        var int i, j, shipIndex, currIndex, currRightDown;
        var int inWhileI, inWhileJ;
        var Square cur;
        var boolean continue, whileBreaker;

        let i = 0;
        let j = 0;
        let inWhileI = 0;
        let inWhileJ = 0;
        let currIndex = 0; 
        let shipIndex = 0;
        let currRightDown = -1;
        let whileBreaker = true;
        let cur = leftData[currIndex];

        while(i < 10){
            while (j < 10){

                let currIndex = (10 * i) + j;
                let cur = leftData[currIndex];
                
                if (cur.getIsChosen()){
                    let currRightDown = checkRightNeighbour(i,j);

                    // both (right and down or down and diagonal or right and digonal)
                    if (currRightDown = 3){
                        return false;
                    }
                    
                    //down
                    if (currRightDown = 1 & ((cur.getShipIndex()=-1))){

                        let inWhileI = i;
                        let inWhileJ = j;

                        while(whileBreaker & (checkBorders(inWhileI, inWhileJ))){
                            let cur = leftData[currIndex];

                            if ( (~(cur.getIsChosen())) | ~(cur.getShipIndex()=-1) ){
                                let whileBreaker = false;
                            }else{

                                if (checkLeftRightNeighbours(inWhileI,inWhileJ)){
                                    return false;   
                                }
                                let cur = leftData[currIndex];
                                do cur.setShipIndex(shipIndex);
                                do shipManager.addToPlayerShip(shipIndex, cur);

                                let currIndex = currIndex + 10;
                                let inWhileI = inWhileI + 1;
                            }
                        }
                        if (currIndex > ((10*(i+5)) + j )){
                            return false;
                        }
                        let shipIndex = shipIndex + 1;
                    }
                    
                    // none
                    if (currRightDown = 0 & ((cur.getShipIndex()=-1))){
                        let cur = leftData[currIndex];
                        do cur.setShipIndex(shipIndex);
                        do shipManager.addToPlayerShip(shipIndex, cur);
                        let shipIndex = shipIndex + 1;
                    }

                    // right
                    if (currRightDown = 2 & ((cur.getShipIndex()=-1))){
                        let inWhileI = i;
                        let inWhileJ = j;

                        while(whileBreaker & (checkBorders(inWhileI, inWhileJ))){
                            let cur = leftData[currIndex];

                            if ( (~(cur.getIsChosen())) | (~(cur.getShipIndex()=-1)) ){
                                let whileBreaker = false;
                            }else{
                                if (checkDownNeighbour(i,j)){
                                    return false;   
                                }
                                
                                let cur = leftData[currIndex];
                                do cur.setShipIndex(shipIndex);
                                do shipManager.addToPlayerShip(shipIndex, cur);

                                let currIndex = currIndex + 1;
                                let inWhileJ = inWhileJ + 1;
                            }
                        }
                        
                        if (currIndex > ((10*i) + j + 5)){
                            return false;
                        }

                        let shipIndex = shipIndex + 1;
                        let currIndex = currIndex + 1;
                    }

                }

                let whileBreaker = true;
                let j = j + 1;
                let currRightDown = -1;

            }
            let j = 0;
            
            let i = i + 1;
        }

        return true;
    }

    method boolean validateShips(){
        return shipManager.validate();
    }

    method void restart(){
        var int i;
        var Square sq;

        let i = 0;

        while(i<100){
            let sq = leftData[i];
            do sq.erase();
            let i = i + 1;
        }

        let i = 0;
        
        while(i<100){
            let sq = rightData[i];
            do sq.erase();
            let i = i + 1;
        }

        return;
    }

    method void reset(){
        do restart();

        let leftData = initializeBoard(startXLeft,startYLeft);
        let rightData = initializeBoard(startXRight,startYRight);
        
        let shipManager = ShipManager.new();

        return;
    }

    method void strikeComputer(Coord c){
        var Square sq;
        var int shipIndex;

        let sq = rightData[(c.getY() * 10) + c.getX()];
        let shipIndex =  sq.strike();

        if (~(shipIndex = -1)){
            do shipManager.checkComputerSink(shipIndex);
        }

        return;
    }


    ////////////////////////// PRINTER //////////////////////////

    method void printPos(int i, int j){
        do Output.printString("( ");
        do Output.printInt(i);
        do Output.printString(" , ");
        do Output.printInt(j);
        do Output.printString(" ) ");
        do Output.println();

        return;
    }

    ////////////////////////// GETTER AND SETTER //////////////////////////

    method ShipManager getShipManager(){
        return shipManager;
    }


    ////////////////////////// CHCKERS //////////////////////////
    method boolean checkBorders(int i, int j){
        return ((i > -1) & (i < 10) & (j > -1) & (j < 10)); 
    }

    // i aris y
    method boolean checkDownNeighbour(int i, int j){
       
        return (checkSquare(i + 1, j ));
    }

    method boolean checkLeftRightNeighbours(int i, int j){
        return  (checkSquare(i, j + 1)) | (checkSquare(i, j - 1));
    }


    method boolean checkSquare(int i, int j){
        var Square curSq;
        if (checkBorders(i,j)){
            let curSq = leftData[(10*(i))+j];
            return curSq.getIsChosen();
        }else{
           return false;
        }
    }

    method boolean checkRightSquare(int i, int j){
        var Square curSq;
        if (checkBorders(i,j)){
            let curSq = rightData[(10*(i))+j];
            return (~(curSq.getIsChosen()));
        }else{
           return true;
        }
    }


    method int checkRightNeighbour(int i, int j){
        
        var boolean isRight, isDown, isDiagonal;
        let isRight = checkSquare(i,j+1);
        let isDown = checkSquare(i+1,j);
        let isDiagonal = checkSquare(i+1,j+1);

        if ((isRight & isDown) | isDiagonal ){
            return 3;
        }

        if (isDown){
            return 1;
        }
        
        if (isRight){
            return 2;
        }
    
        return 0;
    }

    method boolean isCoordChosen(Coord c){
        var Square s;

        if (c.getX()<0 | c.getX()>9 | c.getY()<0 | c.getY()>9){
            return false;
        }
        
        let s = leftData[c.getX()+((c.getY())*10)];
        return s.getIsChosen();
    }


    method boolean isCoordStroke(Coord c){
        var Square s;

        if (c.getX()<0 | c.getX()>9 | c.getY()<0 | c.getY()>9){
            return false;
        }
        
        let s = rightData[c.getX()+((c.getY())*10)];
        return s.getIsStroke();
    }

    method void markSquare(int x, int y){
        var Square cur;
        let cur = leftData[(x+(y*10))];
        do cur.choose();
        return;
    }


    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }


}